<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Guide to Camel’s SEDA, Direct and VM components(FW) | 油腻中年大叔</title>
    <meta name="description" content="你想要的这里都没有，你不想要的这里都有">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css">
    
    <link rel="preload" href="/assets/css/styles.7863e8ac.css" as="style"><link rel="preload" href="/assets/js/app.7863e8ac.js" as="script"><link rel="preload" href="/assets/js/69.a5a81dbc.js" as="script"><link rel="prefetch" href="/assets/js/0.eb7108e7.js"><link rel="prefetch" href="/assets/js/1.d8ec4d72.js"><link rel="prefetch" href="/assets/js/2.28f90b8d.js"><link rel="prefetch" href="/assets/js/3.6001361f.js"><link rel="prefetch" href="/assets/js/4.80c27a58.js"><link rel="prefetch" href="/assets/js/5.2e2f809b.js"><link rel="prefetch" href="/assets/js/6.0d0d8441.js"><link rel="prefetch" href="/assets/js/7.8e4037c3.js"><link rel="prefetch" href="/assets/js/8.5752a787.js"><link rel="prefetch" href="/assets/js/9.8329deb8.js"><link rel="prefetch" href="/assets/js/10.4843c5ba.js"><link rel="prefetch" href="/assets/js/11.9e8b7549.js"><link rel="prefetch" href="/assets/js/12.02c0fa30.js"><link rel="prefetch" href="/assets/js/13.f5d738e8.js"><link rel="prefetch" href="/assets/js/14.ca4b3249.js"><link rel="prefetch" href="/assets/js/15.cf61b2ec.js"><link rel="prefetch" href="/assets/js/16.2b67aa0e.js"><link rel="prefetch" href="/assets/js/17.b99a459f.js"><link rel="prefetch" href="/assets/js/18.2d5afa9a.js"><link rel="prefetch" href="/assets/js/19.6c36dff4.js"><link rel="prefetch" href="/assets/js/20.3e0dc870.js"><link rel="prefetch" href="/assets/js/21.227ee5ec.js"><link rel="prefetch" href="/assets/js/22.05c1f0f0.js"><link rel="prefetch" href="/assets/js/23.c6dbeed0.js"><link rel="prefetch" href="/assets/js/24.957b4252.js"><link rel="prefetch" href="/assets/js/25.b50e4879.js"><link rel="prefetch" href="/assets/js/26.1b2b16cf.js"><link rel="prefetch" href="/assets/js/27.2f0f5e4c.js"><link rel="prefetch" href="/assets/js/28.ffafaa79.js"><link rel="prefetch" href="/assets/js/29.38ab4732.js"><link rel="prefetch" href="/assets/js/30.7258c2eb.js"><link rel="prefetch" href="/assets/js/31.6cc6f25e.js"><link rel="prefetch" href="/assets/js/32.cae8f5c2.js"><link rel="prefetch" href="/assets/js/33.7bac5900.js"><link rel="prefetch" href="/assets/js/34.e457a7ab.js"><link rel="prefetch" href="/assets/js/35.6a4f99be.js"><link rel="prefetch" href="/assets/js/36.3fa7b425.js"><link rel="prefetch" href="/assets/js/37.9627a576.js"><link rel="prefetch" href="/assets/js/38.8f902270.js"><link rel="prefetch" href="/assets/js/39.2fb6b1fd.js"><link rel="prefetch" href="/assets/js/40.0f992849.js"><link rel="prefetch" href="/assets/js/41.1921a30c.js"><link rel="prefetch" href="/assets/js/42.196053b0.js"><link rel="prefetch" href="/assets/js/43.6a2cc6b2.js"><link rel="prefetch" href="/assets/js/44.c3b31b69.js"><link rel="prefetch" href="/assets/js/45.dd90e897.js"><link rel="prefetch" href="/assets/js/46.547a7ce9.js"><link rel="prefetch" href="/assets/js/47.a62be284.js"><link rel="prefetch" href="/assets/js/48.edc6618c.js"><link rel="prefetch" href="/assets/js/49.b3d5118e.js"><link rel="prefetch" href="/assets/js/50.81540475.js"><link rel="prefetch" href="/assets/js/51.c2c1171b.js"><link rel="prefetch" href="/assets/js/52.ba318094.js"><link rel="prefetch" href="/assets/js/53.a2d5d15e.js"><link rel="prefetch" href="/assets/js/54.3608cfdf.js"><link rel="prefetch" href="/assets/js/55.73c0d459.js"><link rel="prefetch" href="/assets/js/56.9706fe8c.js"><link rel="prefetch" href="/assets/js/57.f5a08e9a.js"><link rel="prefetch" href="/assets/js/58.ea9c9ad0.js"><link rel="prefetch" href="/assets/js/59.9d363669.js"><link rel="prefetch" href="/assets/js/60.8a80b28f.js"><link rel="prefetch" href="/assets/js/61.73e5c6a8.js"><link rel="prefetch" href="/assets/js/62.30aab875.js"><link rel="prefetch" href="/assets/js/63.1e86c5c0.js"><link rel="prefetch" href="/assets/js/64.9c071a1e.js"><link rel="prefetch" href="/assets/js/65.61d8d11c.js"><link rel="prefetch" href="/assets/js/66.dd39544e.js"><link rel="prefetch" href="/assets/js/67.6dd79cd2.js"><link rel="prefetch" href="/assets/js/68.dd07b2a3.js"><link rel="prefetch" href="/assets/js/70.3f26faed.js"><link rel="prefetch" href="/assets/js/71.1234830b.js"><link rel="prefetch" href="/assets/js/72.d4db7f16.js"><link rel="prefetch" href="/assets/js/73.e2b0a283.js"><link rel="prefetch" href="/assets/js/74.db6d3ebc.js"><link rel="prefetch" href="/assets/js/75.4516323c.js"><link rel="prefetch" href="/assets/js/76.a086fd94.js"><link rel="prefetch" href="/assets/js/77.165f6d28.js"><link rel="prefetch" href="/assets/js/78.81cd058e.js"><link rel="prefetch" href="/assets/js/79.fde8c00b.js"><link rel="prefetch" href="/assets/js/80.142b728c.js"><link rel="prefetch" href="/assets/js/81.367c9c5e.js"><link rel="prefetch" href="/assets/js/82.d23176e0.js"><link rel="prefetch" href="/assets/js/83.d9571f6f.js"><link rel="prefetch" href="/assets/js/84.6214056c.js"><link rel="prefetch" href="/assets/js/85.66cc6092.js"><link rel="prefetch" href="/assets/js/86.18dba812.js"><link rel="prefetch" href="/assets/js/87.9506d9f8.js"><link rel="prefetch" href="/assets/js/88.b42d6720.js"><link rel="prefetch" href="/assets/js/89.5c0033c4.js"><link rel="prefetch" href="/assets/js/90.069a50d4.js"><link rel="prefetch" href="/assets/js/91.61fe3c31.js"><link rel="prefetch" href="/assets/js/92.e4211585.js"><link rel="prefetch" href="/assets/js/93.6df74471.js"><link rel="prefetch" href="/assets/js/94.d61ebe6e.js"><link rel="prefetch" href="/assets/js/95.c60c8a69.js"><link rel="prefetch" href="/assets/js/96.e3124488.js"><link rel="prefetch" href="/assets/js/97.bce37e32.js"><link rel="prefetch" href="/assets/js/98.a1fb95ac.js"><link rel="prefetch" href="/assets/js/99.f9c12b84.js"><link rel="prefetch" href="/assets/js/100.0b3aaca9.js"><link rel="prefetch" href="/assets/js/101.03f32ae7.js"><link rel="prefetch" href="/assets/js/102.69cca032.js"><link rel="prefetch" href="/assets/js/103.190dc3ef.js"><link rel="prefetch" href="/assets/js/104.6e7ceda7.js"><link rel="prefetch" href="/assets/js/105.f852f5a7.js"><link rel="prefetch" href="/assets/js/106.9335f238.js"><link rel="prefetch" href="/assets/js/107.1404f516.js"><link rel="prefetch" href="/assets/js/108.dd6bb5e3.js"><link rel="prefetch" href="/assets/js/109.a87f5640.js"><link rel="prefetch" href="/assets/js/110.fb0da049.js"><link rel="prefetch" href="/assets/js/111.cc64ddd7.js"><link rel="prefetch" href="/assets/css/112.styles.75c39ee5.css"><link rel="prefetch" href="/assets/js/112.75c39ee5.js"><link rel="prefetch" href="/assets/css/113.styles.407e8d7f.css"><link rel="prefetch" href="/assets/js/113.407e8d7f.js">
    <link rel="stylesheet" href="/assets/css/112.styles.75c39ee5.css"><link rel="stylesheet" href="/assets/css/113.styles.407e8d7f.css"><link rel="stylesheet" href="/assets/css/styles.7863e8ac.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">油腻中年大叔</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/dart/" class="nav-link">Dart</a></div><div class="nav-item"><a href="/spring/" class="nav-link">spring</a></div><div class="nav-item"><a href="/drools/" class="nav-link">规则和业务流程</a></div><div class="nav-item"><a href="/eip/" class="nav-link router-link-active">EIP集成工具</a></div><div class="nav-item"><a href="/other/" class="nav-link">杂项</a></div><div class="nav-item"><a href="/algorithms/" class="nav-link">算法</a></div><div class="nav-item"><a href="/riding/" class="nav-link">骑行</a></div><div class="nav-item"><a href="/ev3/" class="nav-link">LEGO EV3 </a></div><div class="nav-item"><a href="/rubik/" class="nav-link">魔方</a></div><div class="nav-item"><a href="/mb/" class="nav-link">Micro:bit </a></div><div class="nav-item"><a href="/math/" class="nav-link">小学数学 </a></div><div class="nav-item"><a href="/eng/" class="nav-link">小学英语 </a></div><div class="nav-item"><a href="/jp/" class="nav-link">日语 </a></div><div class="nav-item"><a href="/gs1/" class="nav-link">GS-1</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/dart/" class="nav-link">Dart</a></div><div class="nav-item"><a href="/spring/" class="nav-link">spring</a></div><div class="nav-item"><a href="/drools/" class="nav-link">规则和业务流程</a></div><div class="nav-item"><a href="/eip/" class="nav-link router-link-active">EIP集成工具</a></div><div class="nav-item"><a href="/other/" class="nav-link">杂项</a></div><div class="nav-item"><a href="/algorithms/" class="nav-link">算法</a></div><div class="nav-item"><a href="/riding/" class="nav-link">骑行</a></div><div class="nav-item"><a href="/ev3/" class="nav-link">LEGO EV3 </a></div><div class="nav-item"><a href="/rubik/" class="nav-link">魔方</a></div><div class="nav-item"><a href="/mb/" class="nav-link">Micro:bit </a></div><div class="nav-item"><a href="/math/" class="nav-link">小学数学 </a></div><div class="nav-item"><a href="/eng/" class="nav-link">小学英语 </a></div><div class="nav-item"><a href="/jp/" class="nav-link">日语 </a></div><div class="nav-item"><a href="/gs1/" class="nav-link">GS-1</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/eip/camelcheatsheet.html" class="sidebar-link">Camel Cheat Sheet</a></li><li><a href="/eip/camel-split.html" class="sidebar-link">Camel分解消息</a></li><li><a href="/eip/camel-content-router.html" class="sidebar-link">Camel内容路由</a></li><li><a href="/eip/camel-component-custom.html" class="sidebar-link">自定义Camel组件</a></li><li><a href="/eip/camel-test.html" class="sidebar-link">Camel测试</a></li><li><a href="/eip/camel-seda-direct-vm.html" class="active sidebar-link">Camel SEDA Direct VM组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#first…an-example-scenario" class="sidebar-link">First…an example scenario</a></li><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#direct-component" class="sidebar-link">Direct component</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#example-using-the-direct-component" class="sidebar-link">Example: using the Direct component</a></li></ul></li><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#direct-vm-component" class="sidebar-link">Direct-VM component</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#example-using-the-direct-vm-component" class="sidebar-link">Example: using the Direct-VM component</a></li></ul></li><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#seda-component" class="sidebar-link">SEDA component</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#example-using-the-seda-component" class="sidebar-link">Example: Using the SEDA component</a></li></ul></li><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#vm-component" class="sidebar-link">VM component</a></li><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#guide-to-camel’s-seda-direct-and-vm-components" class="sidebar-link">Guide to Camel’s SEDA, Direct and VM components</a></li><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#drawbacks-of-seda-and-vm" class="sidebar-link">Drawbacks of SEDA and VM</a></li><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#summary-and-best-practices" class="sidebar-link">Summary and best practices</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#seda-vs-direct" class="sidebar-link">SEDA vs Direct:</a></li><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#vm-vs-direct-vm" class="sidebar-link">VM vs Direct-VM:</a></li><li class="sidebar-sub-header"><a href="/eip/camel-seda-direct-vm.html#comparison-of-direct-seda-vm-and-direct-vm" class="sidebar-link">Comparison of Direct, SEDA, VM and Direct-VM</a></li></ul></li></ul></li><li><a href="/eip/loop-in-pentaho.html" class="sidebar-link">在pentaho中使用循环</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="guide-to-camel’s-seda-direct-and-vm-components-fw"><a href="#guide-to-camel’s-seda-direct-and-vm-components-fw" aria-hidden="true" class="header-anchor">#</a> Guide to Camel’s SEDA, Direct and VM components(FW)</h1> <p>(from ：https://cleverbuilder.com/articles/camel-direct-vm-seda/, author:Tom Donohue)</p> <p>When designing your Camel routes, you may sometimes want a route to have multiple inputs. Maybe you want to receive messages from a web service and from a JMS queue.</p> <p>You can’t have multiple from() methods in the same route, so how can you have multiple entry points to the same route?</p> <p>Similarly, you might want to reuse the same Camel message processing logic in multiple places, so how do you avoid duplicating code?</p> <p>The answer to both these questions is to join your routes together, using Camel’s in-memory messaging components: Direct, Direct-VM, VM and SEDA.</p> <p>In this article I’ll explain each of these components, how they differ, and how you can use them to make your routes more modular and awesome.</p> <h2 id="first…an-example-scenario"><a href="#first…an-example-scenario" aria-hidden="true" class="header-anchor">#</a> First…an example scenario</h2> <p>First I’m going to start with an example.</p> <p>I have defined a route that validates an incoming order, by passing a message to some underlying system. My orders initially arrive through JMS messages.</p> <p><img src="/assets/img/direct-vm-seda-example.18b5add1.png" alt="images"></p> <p>But what happens when orders start coming from new sources - such as a file upload, or a web service call?</p> <p>To avoid having to repeat the same route code, Camel has features built-in which allow routes to have multiple inputs, by using a range of joining components to glue these routes together.</p> <p>So how does it work? Camel glues endpoints together using the components Direct, VM and SEDA.</p> <p>These components join your Camel routes together in different ways. They are collectively known as Camel’s in-memory messaging components, because they allow messages to be passed between routes, while the message stays in memory at all times. This is a really important detail, which I’ll touch on again later.</p> <p>But for now, let’s now look at each of these components to see how they differ, and where you might use them.</p> <h2 id="direct-component"><a href="#direct-component" aria-hidden="true" class="header-anchor">#</a> Direct component</h2> <p>This has to be one of the most frequently-asked questions by Camel beginners:</p> <blockquote><blockquote><p>What does “direct” mean in a route?</p></blockquote></blockquote> <p><img src="/assets/img/direct-illustr.94866926.gif" alt="images"></p> <p>You’ve probably seen the code direct:... in so many Camel tutorials on the web. But what does direct actually do?</p> <p>direct is one of the most simple ways of linking your routes together. When it’s used in a from() definition, it creates a synchronous endpoint that can be invoked by other Camel routes. For example, this code which starts with from(direct):</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;direct:yourname&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>…will create a Direct endpoint called yourname. That same endpoint can then be invoked in another to() statement somewhere else, like this:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token string">&quot;direct:yourname&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sends the message to the direct:yourname endpoint</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Apache Camel’s Direct component joins routes in a synchronous way. This means that when one route sends a message to another direct endpoint using to(&quot;direct:myroute&quot;), the route myroute will be executed in the same thread as the first route, and a response message will be returned.</p> <p>In examples, it’s often used because it provides a simple entry point into a route, without having to expose a web service, or otherwise rely on an external interface.</p> <h3 id="example-using-the-direct-component"><a href="#example-using-the-direct-component" aria-hidden="true" class="header-anchor">#</a> Example: using the Direct component</h3> <p>Example: using the Direct component</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;file:/home/files/in&quot;</span><span class="token punctuation">)</span>       <span class="token comment">// receive a file</span>
    <span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token string">&quot;direct:processTheFile&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// send to direct endpoint</span>
    <span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token string">&quot;Body is now ${body}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// will print 'Eggs!'</span>

<span class="token comment">// meanwhile...    </span>
<span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;direct:processTheFile&quot;</span><span class="token punctuation">)</span>     <span class="token comment">// receive from direct endpoint</span>
    <span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">&quot;Eggs!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// modify the message body</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>This very simple example receives files using Camel’s File component. Each file processed is passed, as an Exchange, to the direct endpoint processTheFile.</p> <p>Separately, we have defined the processTheFile endpoint as the start component for a route which modifies the message body. Once this is done, the new message is returned back to the calling route. All of this happens synchronously, within the same thread.</p> <p>The simplicity of Direct comes with some drawbacks.</p> <p>Direct endpoints can only be accessed by other routes that are running in the same CamelContext and in the same JVM. This means that you cannot access a Direct endpoint from another CamelContext. Remember the CamelContext is the container where your Camel routes are created and booted up.</p> <p>So what happens if you want to access a route in another CamelContext? You use the next component, Direct-VM.</p> <h2 id="direct-vm-component"><a href="#direct-vm-component" aria-hidden="true" class="header-anchor">#</a> Direct-VM component</h2> <p>Direct-VM is a component that allows you to synchronously call another endpoint in the same JVM, even if it’s in a different CamelContext.</p> <p>When used as a start component, Direct-VM exposes that route as an endpoint which can be invoked synchronously from another route.</p> <p>The difference with the Direct-VM component is that direct-vm endpoints can be seen from other Camel Contexts, as long as they share the same Java Virtual Machine (JVM).</p> <h3 id="example-using-the-direct-vm-component"><a href="#example-using-the-direct-vm-component" aria-hidden="true" class="header-anchor">#</a> Example: using the Direct-VM component</h3> <p>If we wanted to show off the Direct-VM component, we could define a route in Application A:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;file:src/files/input&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token string">&quot;direct-vm:process-file&quot;</span><span class="token punctuation">)</span> <span class="token comment">// invoke the direct-vm endpoint</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Which would call this Direct endpoint, located in Application B…:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;direct-vm:process-file&quot;</span><span class="token punctuation">)</span>    <span class="token comment">// receive from direct-vm endpoint</span>
    <span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token string">&quot;log:samplelog&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// log the message</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>As long as both of these applications are running in the same JVM – for example, using an application container, like Apache Karaf, Wildfly or even different CamelContexts in the same Spring Boot application – then Application A will be able to call the direct-vm endpoint in Application B.</p> <p>This opens up possibilities of linking routes together that were not developed in the same CamelContext. For example, you might use this component if you have different CamelContexts deployed in one container - such as when you’re deploying into JBoss Fuse or Talend ESB.</p> <h2 id="seda-component"><a href="#seda-component" aria-hidden="true" class="header-anchor">#</a> SEDA component</h2> <p>Camel’s SEDA component allows you to join routes together using a simple queue.</p> <p>In a Camel route, when a message is sent to a SEDA endpoint, it is stored in a basic in-memory queue, and control is returned back to the calling route immediately.</p> <p>Then, independently, a SEDA consumer picks up the message from the queue, and begins processing it.</p> <h3 id="example-using-the-seda-component"><a href="#example-using-the-seda-component" aria-hidden="true" class="header-anchor">#</a> Example: Using the SEDA component</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code>
<span class="token function">rest</span><span class="token punctuation">(</span><span class="token string">&quot;/orders&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment">// receive an order via REST</span>
    <span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token string">&quot;seda:processOrder&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// send to the seda queue</span>
    <span class="token punctuation">.</span><span class="token function">setBody</span><span class="token punctuation">(</span><span class="token string">&quot;Thanks for ordering!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// create a REST response</span>
    
<span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;seda:processOrder&quot;</span><span class="token punctuation">)</span>             <span class="token comment">// receive from the seda queue</span>
    <span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Processing an order...&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span><span class="token string">&quot;file:orders/out&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>In the example above, messages will be received via a REST service and published to the SEDA endpoint. Messages arrive at the processOrder SEDA endpoint and are processed, where they are written to a location on disk, using the file: component.</p> <p>SEDA does this by creating its own buffer which is used to store the incoming messages. Out of the box, SEDA creates a pool of threads to process incoming messages, meaning that several messages can be processed at once, making it potentially more performant.</p> <p>In this way, SEDA can be thought of as a simple replacement for JMS queues. It provides queue-like functionality, but without the overhead of running an external message broker like ActiveMQ.</p> <p>Remember that Camel publishes messages to a SEDA endpoint asynchronously.</p> <p>You can only access SEDA endpoints that are located in the same CamelContext. So what happens if you want to send a message to a SEDA queue in another CamelContext? You use the next component, VM.</p> <p>Guide to Camel’s SEDA, Direct and VM components
Updated: May 22, 2018
Guide to Camel’s SEDA, Direct and VM components</p> <p>When designing your Camel routes, you may sometimes want a route to have multiple inputs. Maybe you want to receive messages from a web service and from a JMS queue.</p> <p>You can’t have multiple from() methods in the same route, so how can you have multiple entry points to the same route?</p> <p>Similarly, you might want to reuse the same Camel message processing logic in multiple places, so how do you avoid duplicating code?</p> <p>The answer to both these questions is to join your routes together, using Camel’s in-memory messaging components: Direct, Direct-VM, VM and SEDA.</p> <p>In this article I’ll explain each of these components, how they differ, and how you can use them to make your routes more modular and awesome.</p> <p>ON THIS PAGE
FIRST…AN EXAMPLE SCENARIO
DIRECT COMPONENT
EXAMPLE: USING THE DIRECT COMPONENT
DIRECT-VM COMPONENT
EXAMPLE: USING THE DIRECT-VM COMPONENT
SEDA COMPONENT
EXAMPLE: USING THE SEDA COMPONENT
VM COMPONENT
DRAWBACKS OF SEDA AND VM
SUMMARY AND BEST PRACTICES
COMPARISON OF DIRECT, SEDA, VM AND DIRECT-VM
First…an example scenario
First I’m going to start with an example.</p> <p>I have defined a route that validates an incoming order, by passing a message to some underlying system. My orders initially arrive through JMS messages.</p> <p>Joining camel routes example scenario</p> <p>But what happens when orders start coming from new sources - such as a file upload, or a web service call?</p> <p>To avoid having to repeat the same route code, Camel has features built-in which allow routes to have multiple inputs, by using a range of joining components to glue these routes together.</p> <p>So how does it work? Camel glues endpoints together using the components Direct, VM and SEDA.</p> <p>These components join your Camel routes together in different ways. They are collectively known as Camel’s in-memory messaging components, because they allow messages to be passed between routes, while the message stays in memory at all times. This is a really important detail, which I’ll touch on again later.</p> <p>But for now, let’s now look at each of these components to see how they differ, and where you might use them.</p> <p>Direct component
This has to be one of the most frequently-asked questions by Camel beginners:</p> <p>What does “direct” mean in a route?</p> <p>The Direct component in Camel</p> <p>You’ve probably seen the code direct:... in so many Camel tutorials on the web. But what does direct actually do?</p> <p>direct is one of the most simple ways of linking your routes together. When it’s used in a from() definition, it creates a synchronous endpoint that can be invoked by other Camel routes. For example, this code which starts with from(direct):</p> <p>from(&quot;direct:yourname&quot;)...
…will create a Direct endpoint called yourname. That same endpoint can then be invoked in another to() statement somewhere else, like this:</p> <p>.to(&quot;direct:yourname&quot;);  // sends the message to the direct:yourname endpoint
Apache Camel’s Direct component joins routes in a synchronous way. This means that when one route sends a message to another direct endpoint using to(&quot;direct:myroute&quot;), the route myroute will be executed in the same thread as the first route, and a response message will be returned.</p> <p>In examples, it’s often used because it provides a simple entry point into a route, without having to expose a web service, or otherwise rely on an external interface.</p> <p>Example: using the Direct component
Let’s illustrate the Direct component with an example:</p> <p>from(&quot;file:/home/files/in&quot;)       // receive a file
.to(&quot;direct:processTheFile&quot;); // send to direct endpoint
.to(&quot;Body is now ${body}&quot;);   // will print 'Eggs!'</p> <p>// meanwhile...<br>
from(&quot;direct:processTheFile&quot;)     // receive from direct endpoint
.setBody(&quot;Eggs!&quot;);            // modify the message body
This very simple example receives files using Camel’s File component. Each file processed is passed, as an Exchange, to the direct endpoint processTheFile.</p> <p>Separately, we have defined the processTheFile endpoint as the start component for a route which modifies the message body. Once this is done, the new message is returned back to the calling route. All of this happens synchronously, within the same thread.</p> <p>The simplicity of Direct comes with some drawbacks.</p> <p>Direct endpoints can only be accessed by other routes that are running in the same CamelContext and in the same JVM. This means that you cannot access a Direct endpoint from another CamelContext. Remember the CamelContext is the container where your Camel routes are created and booted up.</p> <p>So what happens if you want to access a route in another CamelContext? You use the next component, Direct-VM.</p> <p>Direct-VM component
Direct-VM is a component that allows you to synchronously call another endpoint in the same JVM, even if it’s in a different CamelContext.</p> <p>When used as a start component, Direct-VM exposes that route as an endpoint which can be invoked synchronously from another route.</p> <p>The difference with the Direct-VM component is that direct-vm endpoints can be seen from other Camel Contexts, as long as they share the same Java Virtual Machine (JVM).</p> <p>Example: using the Direct-VM component
If we wanted to show off the Direct-VM component, we could define a route in Application A:</p> <p>from(&quot;file:src/files/input&quot;)
.to(&quot;direct-vm:process-file&quot;) // invoke the direct-vm endpoint
Which would call this Direct endpoint, located in Application B…:</p> <p>from(&quot;direct-vm:process-file&quot;)    // receive from direct-vm endpoint
.to(&quot;log:samplelog&quot;);         // log the message
As long as both of these applications are running in the same JVM – for example, using an application container, like Apache Karaf, Wildfly or even different CamelContexts in the same Spring Boot application – then Application A will be able to call the direct-vm endpoint in Application B.</p> <p>This opens up possibilities of linking routes together that were not developed in the same CamelContext. For example, you might use this component if you have different CamelContexts deployed in one container - such as when you’re deploying into JBoss Fuse or Talend ESB.</p> <p>SEDA component
Camel’s SEDA component allows you to join routes together using a simple queue.</p> <p>In a Camel route, when a message is sent to a SEDA endpoint, it is stored in a basic in-memory queue, and control is returned back to the calling route immediately.</p> <p>Then, independently, a SEDA consumer picks up the message from the queue, and begins processing it.</p> <p>Example: Using the SEDA component
Here’s an example of a SEDA queue in action:</p> <p>rest(&quot;/orders&quot;).post()                // receive an order via REST
.to(&quot;seda:processOrder&quot;);         // send to the seda queue
.setBody(&quot;Thanks for ordering!&quot;); // create a REST response</p> <p>from(&quot;seda:processOrder&quot;)             // receive from the seda queue
.log(&quot;Processing an order...&quot;)
.to(&quot;file:orders/out&quot;);<br>
In the example above, messages will be received via a REST service and published to the SEDA endpoint. Messages arrive at the processOrder SEDA endpoint and are processed, where they are written to a location on disk, using the file: component.</p> <p>SEDA does this by creating its own buffer which is used to store the incoming messages. Out of the box, SEDA creates a pool of threads to process incoming messages, meaning that several messages can be processed at once, making it potentially more performant.</p> <p>In this way, SEDA can be thought of as a simple replacement for JMS queues. It provides queue-like functionality, but without the overhead of running an external message broker like ActiveMQ.</p> <p>Remember that Camel publishes messages to a SEDA endpoint asynchronously.</p> <p>You can only access SEDA endpoints that are located in the same CamelContext. So what happens if you want to send a message to a SEDA queue in another CamelContext? You use the next component, VM.</p> <h2 id="vm-component"><a href="#vm-component" aria-hidden="true" class="header-anchor">#</a> VM component</h2> <p>In a similar way to how Direct and Direct-VM are related, VM is a similar component to SEDA.</p> <p>When used as a start component, SEDA allows a route to be invoked asynchronously from another route.</p> <p>However the difference between SEDA and VM is that the VM component allows endpoints to be accessed from different Camel Contexts, as long as they are running in the same JVM.</p> <p>Again, the VM component opens up possibilities of linking routes together that were not developed in the same Camel Context, in an asynchronous manner.</p> <h2 id="guide-to-camel’s-seda-direct-and-vm-components"><a href="#guide-to-camel’s-seda-direct-and-vm-components" aria-hidden="true" class="header-anchor">#</a> Guide to Camel’s SEDA, Direct and VM components</h2> <p>Updated: May 22, 2018
Guide to Camel’s SEDA, Direct and VM components</p> <p>When designing your Camel routes, you may sometimes want a route to have multiple inputs. Maybe you want to receive messages from a web service and from a JMS queue.</p> <p>You can’t have multiple from() methods in the same route, so how can you have multiple entry points to the same route?</p> <p>Similarly, you might want to reuse the same Camel message processing logic in multiple places, so how do you avoid duplicating code?</p> <p>The answer to both these questions is to join your routes together, using Camel’s in-memory messaging components: Direct, Direct-VM, VM and SEDA.</p> <p>In this article I’ll explain each of these components, how they differ, and how you can use them to make your routes more modular and awesome.</p> <p>ON THIS PAGE
FIRST…AN EXAMPLE SCENARIO
DIRECT COMPONENT
EXAMPLE: USING THE DIRECT COMPONENT
DIRECT-VM COMPONENT
EXAMPLE: USING THE DIRECT-VM COMPONENT
SEDA COMPONENT
EXAMPLE: USING THE SEDA COMPONENT
VM COMPONENT
DRAWBACKS OF SEDA AND VM
SUMMARY AND BEST PRACTICES
COMPARISON OF DIRECT, SEDA, VM AND DIRECT-VM
First…an example scenario
First I’m going to start with an example.</p> <p>I have defined a route that validates an incoming order, by passing a message to some underlying system. My orders initially arrive through JMS messages.</p> <p>Joining camel routes example scenario</p> <p>But what happens when orders start coming from new sources - such as a file upload, or a web service call?</p> <p>To avoid having to repeat the same route code, Camel has features built-in which allow routes to have multiple inputs, by using a range of joining components to glue these routes together.</p> <p>So how does it work? Camel glues endpoints together using the components Direct, VM and SEDA.</p> <p>These components join your Camel routes together in different ways. They are collectively known as Camel’s in-memory messaging components, because they allow messages to be passed between routes, while the message stays in memory at all times. This is a really important detail, which I’ll touch on again later.</p> <p>But for now, let’s now look at each of these components to see how they differ, and where you might use them.</p> <p>Direct component
This has to be one of the most frequently-asked questions by Camel beginners:</p> <p>What does “direct” mean in a route?</p> <p>The Direct component in Camel</p> <p>You’ve probably seen the code direct:... in so many Camel tutorials on the web. But what does direct actually do?</p> <p>direct is one of the most simple ways of linking your routes together. When it’s used in a from() definition, it creates a synchronous endpoint that can be invoked by other Camel routes. For example, this code which starts with from(direct):</p> <p>from(&quot;direct:yourname&quot;)...
…will create a Direct endpoint called yourname. That same endpoint can then be invoked in another to() statement somewhere else, like this:</p> <p>.to(&quot;direct:yourname&quot;);  // sends the message to the direct:yourname endpoint
Apache Camel’s Direct component joins routes in a synchronous way. This means that when one route sends a message to another direct endpoint using to(&quot;direct:myroute&quot;), the route myroute will be executed in the same thread as the first route, and a response message will be returned.</p> <p>In examples, it’s often used because it provides a simple entry point into a route, without having to expose a web service, or otherwise rely on an external interface.</p> <p>Example: using the Direct component
Let’s illustrate the Direct component with an example:</p> <p>from(&quot;file:/home/files/in&quot;)       // receive a file
.to(&quot;direct:processTheFile&quot;); // send to direct endpoint
.to(&quot;Body is now ${body}&quot;);   // will print 'Eggs!'</p> <p>// meanwhile...<br>
from(&quot;direct:processTheFile&quot;)     // receive from direct endpoint
.setBody(&quot;Eggs!&quot;);            // modify the message body
This very simple example receives files using Camel’s File component. Each file processed is passed, as an Exchange, to the direct endpoint processTheFile.</p> <p>Separately, we have defined the processTheFile endpoint as the start component for a route which modifies the message body. Once this is done, the new message is returned back to the calling route. All of this happens synchronously, within the same thread.</p> <p>The simplicity of Direct comes with some drawbacks.</p> <p>Direct endpoints can only be accessed by other routes that are running in the same CamelContext and in the same JVM. This means that you cannot access a Direct endpoint from another CamelContext. Remember the CamelContext is the container where your Camel routes are created and booted up.</p> <p>So what happens if you want to access a route in another CamelContext? You use the next component, Direct-VM.</p> <p>Direct-VM component
Direct-VM is a component that allows you to synchronously call another endpoint in the same JVM, even if it’s in a different CamelContext.</p> <p>When used as a start component, Direct-VM exposes that route as an endpoint which can be invoked synchronously from another route.</p> <p>The difference with the Direct-VM component is that direct-vm endpoints can be seen from other Camel Contexts, as long as they share the same Java Virtual Machine (JVM).</p> <p>Example: using the Direct-VM component
If we wanted to show off the Direct-VM component, we could define a route in Application A:</p> <p>from(&quot;file:src/files/input&quot;)
.to(&quot;direct-vm:process-file&quot;) // invoke the direct-vm endpoint
Which would call this Direct endpoint, located in Application B…:</p> <p>from(&quot;direct-vm:process-file&quot;)    // receive from direct-vm endpoint
.to(&quot;log:samplelog&quot;);         // log the message
As long as both of these applications are running in the same JVM – for example, using an application container, like Apache Karaf, Wildfly or even different CamelContexts in the same Spring Boot application – then Application A will be able to call the direct-vm endpoint in Application B.</p> <p>This opens up possibilities of linking routes together that were not developed in the same CamelContext. For example, you might use this component if you have different CamelContexts deployed in one container - such as when you’re deploying into JBoss Fuse or Talend ESB.</p> <p>SEDA component
Camel’s SEDA component allows you to join routes together using a simple queue.</p> <p>In a Camel route, when a message is sent to a SEDA endpoint, it is stored in a basic in-memory queue, and control is returned back to the calling route immediately.</p> <p>Then, independently, a SEDA consumer picks up the message from the queue, and begins processing it.</p> <p>Example: Using the SEDA component
Here’s an example of a SEDA queue in action:</p> <p>rest(&quot;/orders&quot;).post()                // receive an order via REST
.to(&quot;seda:processOrder&quot;);         // send to the seda queue
.setBody(&quot;Thanks for ordering!&quot;); // create a REST response</p> <p>from(&quot;seda:processOrder&quot;)             // receive from the seda queue
.log(&quot;Processing an order...&quot;)
.to(&quot;file:orders/out&quot;);<br>
In the example above, messages will be received via a REST service and published to the SEDA endpoint. Messages arrive at the processOrder SEDA endpoint and are processed, where they are written to a location on disk, using the file: component.</p> <p>SEDA does this by creating its own buffer which is used to store the incoming messages. Out of the box, SEDA creates a pool of threads to process incoming messages, meaning that several messages can be processed at once, making it potentially more performant.</p> <p>In this way, SEDA can be thought of as a simple replacement for JMS queues. It provides queue-like functionality, but without the overhead of running an external message broker like ActiveMQ.</p> <p>Remember that Camel publishes messages to a SEDA endpoint asynchronously.</p> <p>You can only access SEDA endpoints that are located in the same CamelContext. So what happens if you want to send a message to a SEDA queue in another CamelContext? You use the next component, VM.</p> <p>VM component
In a similar way to how Direct and Direct-VM are related, VM is a similar component to SEDA.</p> <p>When used as a start component, SEDA allows a route to be invoked asynchronously from another route.</p> <p>However the difference between SEDA and VM is that the VM component allows endpoints to be accessed from different Camel Contexts, as long as they are running in the same JVM.</p> <p>Again, the VM component opens up possibilities of linking routes together that were not developed in the same Camel Context, in an asynchronous manner.</p> <h2 id="drawbacks-of-seda-and-vm"><a href="#drawbacks-of-seda-and-vm" aria-hidden="true" class="header-anchor">#</a> Drawbacks of SEDA and VM</h2> <p>The biggest drawback of using in-memory messaging like SEDA and VM is that if the application crashes, there’s a big chance you’ll lose all your messages.</p> <p>This isn’t a major consideration if you’re designing the kind of integrations where it doesn’t matter if the message goes missing.</p> <p>But think back to the order processing example at the top of this article. If an order gets lost during a server outage, this potentially means lost business. (Uh-oh.)</p> <p>Have a think about when it’s appropriate to use these in-memory messaging components, and when it might be more appropriate to hand over the message to an external message broker, such as ActiveMQ, for reliability.</p> <p>There isn’t a hard and fast rule. The right solution always depends on your use case. So when designing integrations using Camel, think about what you’d do if you lost messages. Would it matter? If it would, consider using transactions and persistent messaging to minimise any message loss.</p> <h2 id="summary-and-best-practices"><a href="#summary-and-best-practices" aria-hidden="true" class="header-anchor">#</a> Summary and best practices</h2> <p>So now you’ve learned about each component, which should you use, and when?</p> <h3 id="seda-vs-direct"><a href="#seda-vs-direct" aria-hidden="true" class="header-anchor">#</a> SEDA vs Direct:</h3> <ul><li><p>For synchronous (request/response) interactions within the same CamelContext, use Direct</p></li> <li><p>For asynchronous (fire-and-forget) processing within the same CamelContext (to process messages in a queue-like fashion), use SEDA</p></li></ul> <h3 id="vm-vs-direct-vm"><a href="#vm-vs-direct-vm" aria-hidden="true" class="header-anchor">#</a> VM vs Direct-VM:</h3> <ul><li>For synchronous (request/response) interactions in another CamelContext but within the same JVM, use Direct-VM</li> <li>For asynchronous (fire-and-forget) interactions in another CamelContext but within the same JVM, use VM</li></ul> <h3 id="comparison-of-direct-seda-vm-and-direct-vm"><a href="#comparison-of-direct-seda-vm-and-direct-vm" aria-hidden="true" class="header-anchor">#</a> Comparison of Direct, SEDA, VM and Direct-VM</h3> <table><thead><tr><th>Component</th> <th>Type</th> <th>Within same CamelContext</th> <th>Within same JVM</th></tr></thead> <tbody><tr><td>Direct</td> <td>Synchronous</td> <td>Yes</td> <td>No</td></tr> <tr><td>Direct-VM</td> <td>Synchronous</td> <td>Yes</td> <td>Yes</td></tr> <tr><td>SEDA</td> <td>Asynchronous</td> <td>Yes</td> <td>No</td></tr> <tr><td>VM</td> <td>Asynchronous</td> <td>Yes</td> <td>Yes</td></tr></tbody></table></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/eip/camel-test.html" class="prev">
          Camel测试
        </a></span> <span class="next"><a href="/eip/loop-in-pentaho.html">
          在pentaho中使用循环
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/69.a5a81dbc.js" defer></script><script src="/assets/js/app.7863e8ac.js" defer></script>
  </body>
</html>
